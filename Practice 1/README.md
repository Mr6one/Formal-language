# Formal_practice_1

Описание алгоритма:
1. Построим по регулярному выражению НКА с эпсилон переходами.
2. Сделаем эпсилон-замыкание => получим НКА.
3. Преобразуем НКА в ДКА
4. Для всех суффиксов строки будем искать префиксы наибольшей длины. Для этого из каждого состояния автомата запустим DFS. Пусть мы находимся в строке в позиции i. Рассмотрим символ в i + 1. Если из текущего состояния есть переход по этому символу, то сделаем переход, увеличив i на 1. Ответом на задачу будет наибольшая глубина DFS.

Запуск:
1. Переключиться на ветку Practice. Мы должны находиться в Formal_practice_1.
2. Запустить Launcher, передав ему путь от домашней директории до текущей папки. Т.е. если мы находимся в ~/A/B/C/Formal_practice_1, то предать A/B/C/Formal_practice_1 (если передать неправильно, будут проблемы c code coverage). Скрипт соберет проект, запустит тесты, создат отчет о code coverage и отправт его. С более подробной информацией о покрытии кода можно ознакомиться в report/index.html.

Примечание: для ручной проверки из main.cpp следует удалить комментирование main. Это сделано для того, чтобы при линковке тестового файла и main.cpp не было ошибки, связанной с двумя main.
